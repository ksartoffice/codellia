import './style.css';
import {
  initSettings,
  type PendingSettingsState,
  type SettingsApi,
  type SettingsData,
} from './settings';
import { runSetupWizard } from './setup-wizard';
import { mountToolbar, type ToolbarApi } from './toolbar';
import { buildLayout } from './layout';
import { initMonacoEditors, type MonacoType } from './monaco';
import { createPreviewController, type PreviewController } from './preview';
import { getEditableElementAttributes, getEditableElementText } from './element-text';
import {
  createTailwindCompiler,
  type TailwindCompiler,
} from './persistence';
import { resolveDefaultLayout, resolveLayout } from './logic/layout';
import { createDocumentTitleSync } from './logic/document-title';
import { buildMediaHtml } from './logic/media-html';
import { createSaveExportController } from './controllers/save-export-controller';
import { createModalController } from './controllers/modal-controller';
import { createEditorUiController } from './controllers/editor-ui-controller';
import { createViewportController } from './controllers/viewport-controller';
import {
  createNotices,
  NOTICE_ERROR_DURATION_MS,
  NOTICE_IDS,
  NOTICE_SUCCESS_DURATION_MS,
} from './ui/notices';
import { debounce } from './utils/debounce';
import type { AppConfig } from './types/app-config';
import { resolveInitialState } from './bootstrap/resolve-initial-state';
import { __ } from '@wordpress/i18n';

// wp-api-fetch は admin 側でグローバル wp.apiFetch として使える
declare const wp: any;

declare global {
  interface Window {
    CODELLIA: AppConfig;
    monaco?: MonacoType;
    require?: any; // AMD loader
  }
}

const COMPACT_EDITOR_BREAKPOINT = 900;
const HTML_WORD_WRAP_STORAGE_KEY = 'codellia.html.wordWrap';
type HtmlWordWrapMode = 'off' | 'on';

const readHtmlWordWrapMode = (): HtmlWordWrapMode => {
  try {
    return window.localStorage.getItem(HTML_WORD_WRAP_STORAGE_KEY) === 'on' ? 'on' : 'off';
  } catch {
    return 'off';
  }
};

const saveHtmlWordWrapMode = (mode: HtmlWordWrapMode) => {
  try {
    window.localStorage.setItem(HTML_WORD_WRAP_STORAGE_KEY, mode);
  } catch {
    // Ignore storage errors and keep editing.
  }
};

async function main() {
  const cfg = window.CODELLIA;
  const postId = cfg.post_id;
  const mount = document.getElementById('codellia-app');
  if (!mount) return;
  const notices = createNotices({ wp });
  const { createSnackbar, mountNotices, removeNotice, syncNoticeOffset } = notices;
  mountNotices();

  const ui = buildLayout(mount);
  ui.resizer.setAttribute('role', 'separator');
  ui.resizer.setAttribute('aria-orientation', 'vertical');
  ui.editorResizer.setAttribute('role', 'separator');
  ui.editorResizer.setAttribute('aria-orientation', 'horizontal');

  let toolbarApi: ToolbarApi | null = null;
  let editorUiController: ReturnType<typeof createEditorUiController> | null = null;
  const viewportController = createViewportController({
    ui,
    compactDesktopViewportWidth: 1280,
    viewportPresetWidths: {
      mobile: 375,
      tablet: 768,
    },
    previewBadgeHideMs: 2200,
    previewBadgeTransitionMs: 320,
    minLeftWidth: 320,
    minRightWidth: 360,
    desktopMinPreviewWidth: 1024,
    minEditorPaneHeight: 160,
    getCompactEditorMode: () => editorUiController?.isCompactEditorMode() ?? false,
    onViewportModeChange: (mode) => toolbarApi?.update({ viewportMode: mode }),
    onEditorCollapsedChange: (collapsed) => toolbarApi?.update({ editorCollapsed: collapsed }),
  });
  let setupResult: Awaited<ReturnType<typeof runSetupWizard>> | undefined;

  // REST nonce middleware
  if (wp?.apiFetch?.createNonceMiddleware) {
    wp.apiFetch.use(wp.apiFetch.createNonceMiddleware(cfg.restNonce));
  }

  if (cfg.setupRequired) {
    if (!cfg.setupRestUrl || !wp?.apiFetch) {
      ui.app.textContent = __( 'Setup wizard unavailable.', 'codellia' );
      return;
    }

    const setupHost = document.createElement('div');
    setupHost.className = 'cd-setupHost';
    document.body.append(setupHost);

    try {
      setupResult = await runSetupWizard({
        container: setupHost,
        postId,
        restUrl: cfg.setupRestUrl,
        importRestUrl: cfg.importRestUrl,
        apiFetch: wp?.apiFetch,
        backUrl: cfg.listUrl || cfg.backUrl,
        initialTailwindEnabled: Boolean(cfg.tailwindEnabled),
      });
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error('[Codellia] Setup failed', error);
      ui.app.textContent = __( 'Setup failed.', 'codellia' );
      return;
    } finally {
      setupHost.remove();
    }
  }

  const initialState = resolveInitialState(cfg, setupResult);
  let tailwindEnabled = initialState.tailwindEnabled;
  let htmlWordWrapMode: HtmlWordWrapMode = readHtmlWordWrapMode();

  let monaco: MonacoType;
  let htmlModel: import('monaco-editor').editor.ITextModel;
  let cssModel: import('monaco-editor').editor.ITextModel;
  let jsModel: import('monaco-editor').editor.ITextModel;
  let htmlEditor: import('monaco-editor').editor.IStandaloneCodeEditor;
  let cssEditor: import('monaco-editor').editor.IStandaloneCodeEditor;
  let jsEditor: import('monaco-editor').editor.IStandaloneCodeEditor;
  let tailwindCss = initialState.importedGeneratedCss;
  let settingsOpen = false;
  let activeSettingsTab: 'settings' | 'elements' = 'settings';
  const canEditJs = Boolean(cfg.canEditJs);
  let jsEnabled = true;
  let shadowDomEnabled = Boolean(initialState.settingsData?.shadowDomEnabled);
  let shortcodeEnabled = Boolean(initialState.settingsData?.shortcodeEnabled);
  let singlePageEnabled = initialState.settingsData?.singlePageEnabled ?? true;
  let liveHighlightEnabled = initialState.settingsData?.liveHighlightEnabled ?? true;
  let externalScripts = Array.isArray(initialState.settingsData?.externalScripts)
    ? [...initialState.settingsData.externalScripts]
    : [];
  let externalStyles = Array.isArray(initialState.settingsData?.externalStyles)
    ? [...initialState.settingsData.externalStyles]
    : [];
  let hasUnsavedChanges = false;
  let pendingSettingsUpdates: Record<string, unknown> = {};
  let hasUnsavedSettings = false;
  let hasSettingsValidationErrors = false;
  let viewPostUrl = initialState.settingsData?.viewUrl || '';
  let postStatus = initialState.settingsData?.status || 'draft';
  let postTitle = initialState.settingsData?.title || '';
  let postSlug = initialState.settingsData?.slug || '';
  let layoutMode = resolveLayout(initialState.settingsData?.layout);
  let defaultLayout = resolveDefaultLayout(initialState.settingsData?.defaultLayout);
  const syncDocumentTitle = createDocumentTitleSync(document.title, cfg.adminTitleSeparators);
  syncDocumentTitle(postTitle);

  let preview: PreviewController | null = null;
  let settingsApi: SettingsApi | null = null;
  let modalController: ReturnType<typeof createModalController> | null = null;
  let tailwindCompiler: TailwindCompiler | null = null;
  let sendRenderDebounced: (() => void) | null = null;
  let compileTailwindDebounced: (() => void) | null = null;
  let selectedLcId: string | null = null;
  let suppressSelectionClear = 0;
  const selectionListeners = new Set<(lcId: string | null) => void>();
  const contentListeners = new Set<() => void>();

  const notifySelection = () => {
    selectionListeners.forEach((listener) => listener(selectedLcId));
  };

  const subscribeSelection = (listener: (lcId: string | null) => void) => {
    selectionListeners.add(listener);
    listener(selectedLcId);
    return () => selectionListeners.delete(listener);
  };

  const notifyContentChange = () => {
    contentListeners.forEach((listener) => listener());
  };

  const subscribeContentChange = (listener: () => void) => {
    contentListeners.add(listener);
    return () => contentListeners.delete(listener);
  };

  let saveExportController: ReturnType<typeof createSaveExportController> | null = null;

  const getUnsavedFlags = () => {
    if (!saveExportController) {
      return {
        html: false,
        css: false,
        js: false,
        settings: hasUnsavedSettings,
        hasAny: hasUnsavedSettings,
      };
    }
    return saveExportController.getUnsavedFlags();
  };

  const syncUnsavedUi = () => {
    saveExportController?.syncUnsavedUi();
  };

  const markSavedState = () => {
    saveExportController?.markSavedState();
  };

  const syncElementsTabState = () => {
    preview?.sendElementsTabState(settingsOpen && activeSettingsTab === 'elements');
  };

  const getResolvedLayout = () => (layoutMode === 'default' ? defaultLayout : layoutMode);
  const isThemeLayoutActive = () => getResolvedLayout() === 'theme';

  const setSettingsOpen = (open: boolean) => {
    settingsOpen = open;
    ui.app.classList.toggle('is-settings-open', open);
    toolbarApi?.update({ settingsOpen: open });
    syncElementsTabState();
    viewportController.applyViewportLayout();
  };

  const applySavedSettings = (nextSettings: SettingsData, refreshPreview: boolean) => {
    const currentResolved = getResolvedLayout();
    if (typeof nextSettings.viewUrl === 'string') {
      viewPostUrl = nextSettings.viewUrl;
    }
    postStatus = nextSettings.status || postStatus;
    postTitle = nextSettings.title || postTitle;
    postSlug = nextSettings.slug || postSlug;
    shadowDomEnabled = Boolean(nextSettings.shadowDomEnabled);
    shortcodeEnabled = Boolean(nextSettings.shortcodeEnabled);
    singlePageEnabled = nextSettings.singlePageEnabled ?? singlePageEnabled;
    liveHighlightEnabled = nextSettings.liveHighlightEnabled ?? liveHighlightEnabled;
    externalScripts = Array.isArray(nextSettings.externalScripts)
      ? [...nextSettings.externalScripts]
      : [];
    externalStyles = Array.isArray(nextSettings.externalStyles)
      ? [...nextSettings.externalStyles]
      : [];
    const nextLayout = resolveLayout(nextSettings.layout);
    const nextDefaultLayout =
      typeof nextSettings.defaultLayout === 'string'
        ? resolveDefaultLayout(nextSettings.defaultLayout)
        : defaultLayout;
    if (typeof nextSettings.defaultLayout === 'string') {
      defaultLayout = nextDefaultLayout;
    }
    layoutMode = nextLayout;
    setShadowDomEnabled(shadowDomEnabled);
    setLiveHighlightEnabled(liveHighlightEnabled);
    toolbarApi?.update({ viewPostUrl, postStatus, postTitle, postSlug });
    syncDocumentTitle(postTitle);

    const nextResolved = nextLayout === 'default' ? nextDefaultLayout : nextLayout;
    if ((refreshPreview || nextResolved !== currentResolved) && basePreviewUrl) {
      ui.iframe.src = buildPreviewRefreshUrl(getPreviewUrl());
    }
  };

  saveExportController = createSaveExportController({
    apiFetch: wp.apiFetch,
    restUrl: cfg.restUrl,
    restCompileUrl: cfg.restCompileUrl,
    postId,
    canEditJs,
    getHtmlModel: () => htmlModel,
    getCssModel: () => cssModel,
    getJsModel: () => jsModel,
    getTailwindEnabled: () => tailwindEnabled,
    getTailwindCss: () => tailwindCss,
    getExternalScripts: () => externalScripts,
    getExternalStyles: () => externalStyles,
    getShadowDomEnabled: () => shadowDomEnabled,
    getShortcodeEnabled: () => shortcodeEnabled,
    getSinglePageEnabled: () => singlePageEnabled,
    getLiveHighlightEnabled: () => liveHighlightEnabled,
    getPendingSettingsState: () => ({
      pendingSettingsUpdates,
      hasUnsavedSettings,
      hasSettingsValidationErrors,
    }),
    clearPendingSettingsState: () => {
      pendingSettingsUpdates = {};
      hasUnsavedSettings = false;
      hasSettingsValidationErrors = false;
    },
    applySavedSettings,
    applySettingsToSidebar: (settings) => settingsApi?.applySettings(settings),
    createSnackbar,
    noticeIds: {
      save: NOTICE_IDS.save,
      export: NOTICE_IDS.export,
    },
    noticeSuccessMs: NOTICE_SUCCESS_DURATION_MS,
    noticeErrorMs: NOTICE_ERROR_DURATION_MS,
    uiDirtyTargets: {
      htmlTitle: ui.htmlTitle,
      cssTab: ui.cssTab,
      jsTab: ui.jsTab,
      compactHtmlTab: ui.compactHtmlTab,
      compactCssTab: ui.compactCssTab,
      compactJsTab: ui.compactJsTab,
    },
    onUnsavedChange: (nextHasUnsavedChanges) => {
      hasUnsavedChanges = nextHasUnsavedChanges;
      toolbarApi?.update({ hasUnsavedChanges });
    },
  });

  async function handleExport() {
    await saveExportController?.handleExport();
  }

  async function handleSave(): Promise<{ ok: boolean; error?: string }> {
    if (!saveExportController) {
      return { ok: false, error: __('Save failed.', 'codellia') };
    }
    return await saveExportController.handleSave();
  }

  const runSaveShortcut = async () => {
    await handleSave();
  };

  const registerSaveShortcut = (
    editorInstance: import('monaco-editor').editor.IStandaloneCodeEditor
  ) => {
    editorInstance.addAction({
      id: 'codellia.save',
      label: __( 'Save', 'codellia' ),
      keybindings: [monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS],
      run: runSaveShortcut,
    });
  };

  const registerHtmlWordWrapAction = (
    editorInstance: import('monaco-editor').editor.IStandaloneCodeEditor
  ) => {
    editorInstance.addAction({
      id: 'codellia.toggleHtmlWordWrap',
      label: __( 'Toggle HTML word wrap', 'codellia' ),
      keybindings: [monaco.KeyMod.Alt | monaco.KeyCode.KeyZ],
      run: () => {
        htmlWordWrapMode = htmlWordWrapMode === 'on' ? 'off' : 'on';
        editorInstance.updateOptions({ wordWrap: htmlWordWrapMode });
        saveHtmlWordWrapMode(htmlWordWrapMode);
      },
    });
  };

  const basePreviewUrl = cfg.iframePreviewUrl || cfg.previewUrl;
  const buildPreviewLayoutUrl = (url: string, layout: string) => {
    if (!url) {
      return url;
    }
    try {
      const previewUrl = new URL(url, window.location.origin);
      if (layout && layout !== 'default') {
        previewUrl.searchParams.set('codellia_layout', layout);
      } else {
        previewUrl.searchParams.delete('codellia_layout');
      }
      return previewUrl.toString();
    } catch {
      return url;
    }
  };
  const getPreviewUrl = () => buildPreviewLayoutUrl(basePreviewUrl, layoutMode);
  const buildPreviewRefreshUrl = (url: string) => {
    if (!url) {
      return url;
    }
    try {
      const refreshUrl = new URL(url, window.location.origin);
      refreshUrl.searchParams.set('codellia_refresh', Date.now().toString());
      return refreshUrl.toString();
    } catch {
      const hasQuery = url.includes('?');
      const hashIndex = url.indexOf('#');
      const suffix = `${hasQuery ? '&' : '?'}codellia_refresh=${Date.now()}`;
      if (hashIndex === -1) {
        return url + suffix;
      }
      return url.slice(0, hashIndex) + suffix + url.slice(hashIndex);
    }
  };
  const targetOrigin = new URL(getPreviewUrl()).origin;
  let pendingIframeLoad = false;

  const handleIframeLoadEvent = () => {
    if (!preview) {
      pendingIframeLoad = true;
      return;
    }
    preview.handleIframeLoad();
  };

  const handlePreviewMessage = (event: MessageEvent) => {
    preview?.handleMessage(event);
  };

  // Register listeners before src assignment to avoid missing early handshake messages.
  ui.iframe.addEventListener('load', handleIframeLoadEvent);
  window.addEventListener('message', handlePreviewMessage);

  modalController = createModalController({
    apiFetch: wp.apiFetch,
    settingsRestUrl: cfg.settingsRestUrl,
    postId,
    getShadowDomEnabled: () => shadowDomEnabled,
    isThemeLayoutActive,
    getDefaultLayout: () => defaultLayout,
    setLayoutModes: (nextLayout, nextDefaultLayout) => {
      layoutMode = nextLayout;
      defaultLayout = nextDefaultLayout;
    },
    applySettingsToSidebar: (settings) => settingsApi?.applySettings(settings),
    refreshPreview: () => {
      if (basePreviewUrl) {
        ui.iframe.src = buildPreviewRefreshUrl(getPreviewUrl());
      }
    },
    createSnackbar,
    noticeIds: {
      layoutFallback: NOTICE_IDS.layoutFallback,
    },
    noticeErrorMs: NOTICE_ERROR_DURATION_MS,
  });

  toolbarApi = mountToolbar(
    ui.toolbar,
    {
      backUrl: cfg.backUrl || '/wp-admin/',
      listUrl: cfg.listUrl || '',
      canUndo: false,
      canRedo: false,
      editorCollapsed: viewportController.isEditorCollapsed(),
      compactEditorMode: editorUiController?.isCompactEditorMode() ?? false,
      settingsOpen,
      tailwindEnabled,
      viewportMode: viewportController.getViewportMode(),
      hasUnsavedChanges: false,
      viewPostUrl,
      postStatus,
      postTitle,
      postSlug,
    },
    {
      onUndo: () => editorUiController?.getActiveEditor()?.trigger('toolbar', 'undo', null),
      onRedo: () => editorUiController?.getActiveEditor()?.trigger('toolbar', 'redo', null),
      onToggleEditor: () =>
        viewportController.setEditorCollapsed(!viewportController.isEditorCollapsed()),
      onSave: handleSave,
      onExport: handleExport,
      onToggleSettings: () => setSettingsOpen(!settingsOpen),
      onViewportChange: (mode) => viewportController.setViewportMode(mode),
      onUpdatePostIdentity: async ({ title, slug }) => {
        if (!cfg.settingsRestUrl || !wp?.apiFetch) {
          return { ok: false, error: __( 'Settings unavailable.', 'codellia' ) };
        }
        try {
          const response = await wp.apiFetch({
            url: cfg.settingsRestUrl,
            method: 'POST',
            data: {
              post_id: postId,
              updates: {
                title,
                slug,
              },
            },
          });
          if (!response?.ok) {
            return { ok: false, error: response?.error || __( 'Update failed.', 'codellia' ) };
          }
          const nextSettings = response.settings as SettingsData | undefined;
          const nextTitle =
            nextSettings && typeof nextSettings.title === 'string'
              ? nextSettings.title
              : title;
          const nextSlug =
            nextSettings && typeof nextSettings.slug === 'string'
              ? nextSettings.slug
              : slug;
          postTitle = nextTitle;
          postSlug = nextSlug;
          toolbarApi?.update({ postTitle, postSlug });
          settingsApi?.applySettings({ title: postTitle, slug: postSlug });
          syncDocumentTitle(postTitle);
          window.dispatchEvent(
            new CustomEvent('cd-title-updated', { detail: { title: postTitle, slug: postSlug } })
          );
          if (basePreviewUrl) {
            ui.iframe.src = buildPreviewRefreshUrl(getPreviewUrl());
          }
          return { ok: true };
        } catch (error: any) {
          return {
            ok: false,
            error: error?.message || __( 'Update failed.', 'codellia' ),
          };
        }
      },
      onUpdateStatus: async (nextStatus) => {
        if (!cfg.settingsRestUrl || !wp?.apiFetch) {
          return { ok: false, error: __( 'Settings unavailable.', 'codellia' ) };
        }
        const updates =
          nextStatus === 'private'
            ? { status: 'private', visibility: 'private' }
            : { status: nextStatus, visibility: 'public' };
        try {
          const response = await wp.apiFetch({
            url: cfg.settingsRestUrl,
            method: 'POST',
            data: {
              post_id: postId,
              updates,
            },
          });
          if (!response?.ok) {
            return { ok: false, error: response?.error || __( 'Update failed.', 'codellia' ) };
          }
          const nextSettings = response.settings as SettingsData | undefined;
          postStatus =
            nextSettings && typeof nextSettings.status === 'string'
              ? nextSettings.status
              : nextStatus;
          toolbarApi?.update({ postStatus });
          return { ok: true };
        } catch (error: any) {
          return {
            ok: false,
            error: error?.message || __( 'Update failed.', 'codellia' ),
          };
        }
      },
    }
  );
  syncNoticeOffset();
  window.setTimeout(syncNoticeOffset, 0);
  createSnackbar('info', __( 'Loading Monaco...', 'codellia' ), NOTICE_IDS.monaco);

  // iframe
  ui.iframe.src = getPreviewUrl();

  // Monaco
  const monacoSetup = await initMonacoEditors({
    vsPath: cfg.monacoVsPath,
    initialHtml: initialState.initialHtml,
    initialCss: initialState.initialCss,
    initialJs: initialState.initialJs,
    htmlWordWrap: htmlWordWrapMode,
    tailwindEnabled,
    useTailwindDefault: !setupResult?.imported,
    canEditJs,
    htmlContainer: ui.htmlEditorDiv,
    cssContainer: ui.cssEditorDiv,
    jsContainer: ui.jsEditorDiv,
  });

  ({ monaco, htmlModel, cssModel, jsModel, htmlEditor, cssEditor, jsEditor } = monacoSetup);

  registerSaveShortcut(htmlEditor);
  registerSaveShortcut(cssEditor);
  registerSaveShortcut(jsEditor);
  registerHtmlWordWrapAction(htmlEditor);

  removeNotice(NOTICE_IDS.monaco);
  markSavedState();

  const handleBeforeUnload = (event: BeforeUnloadEvent) => {
    if (!hasUnsavedChanges) {
      return;
    }
    event.preventDefault();
    event.returnValue = __( 'You may have unsaved changes.', 'codellia' );
  };

  window.addEventListener('beforeunload', handleBeforeUnload);

  const applyHtmlEdit = (startOffset: number, endOffset: number, nextText: string) => {
    suppressSelectionClear += 1;
    const start = htmlModel.getPositionAt(startOffset);
    const end = htmlModel.getPositionAt(endOffset);
    htmlModel.pushEditOperations(
      [],
      [
        {
          range: new monaco.Range(start.lineNumber, start.column, end.lineNumber, end.column),
          text: nextText,
        },
      ],
      () => null
    );
    suppressSelectionClear = Math.max(0, suppressSelectionClear - 1);
  };

  const insertHtmlAtSelection = (text: string) => {
    const selection = htmlEditor.getSelection();
    const cursor = htmlEditor.getPosition();
    const range =
      selection ||
      new monaco.Range(
        cursor?.lineNumber || 1,
        cursor?.column || 1,
        cursor?.lineNumber || 1,
        cursor?.column || 1
      );
    htmlEditor.pushUndoStop();
    htmlModel.pushEditOperations(
      [],
      [{ range, text }],
      (inverseOperations) => {
        const inverseRange = inverseOperations[0]?.range;
        if (!inverseRange) {
          return null;
        }
        const end = inverseRange.getEndPosition();
        return [new monaco.Selection(end.lineNumber, end.column, end.lineNumber, end.column)];
      }
    );
    htmlEditor.pushUndoStop();
  };

  const openMediaModal = () => {
    if (typeof wp?.media !== 'function') {
      createSnackbar(
        'error',
        __( 'Media library is unavailable.', 'codellia' ),
        NOTICE_IDS.media,
        NOTICE_ERROR_DURATION_MS
      );
      return;
    }

    const frame = wp.media({
      frame: 'post',
      state: 'insert',
      title: __( 'Select media to insert into HTML.', 'codellia' ),
      button: {
        text: __( 'Insert into HTML', 'codellia' ),
      },
      multiple: false,
    });

    frame.on('insert', (selectionArg: any) => {
      const state = frame.state?.();
      const selection = selectionArg || state?.get?.('selection');
      const selectedModel = selection?.first?.();
      const attachment = selectedModel?.toJSON?.();
      if (!attachment || typeof attachment !== 'object') {
        return;
      }
      const display =
        typeof state?.display === 'function'
          ? state.display(selectedModel)?.toJSON?.()
          : undefined;
      const html = buildMediaHtml(
        attachment as Record<string, unknown>,
        display && typeof display === 'object' ? (display as Record<string, unknown>) : undefined,
        wp?.media?.string?.props
      );
      if (!html) {
        createSnackbar(
          'warning',
          __( 'The selected media has no URL and was not inserted.', 'codellia' ),
          NOTICE_IDS.media,
          NOTICE_ERROR_DURATION_MS
        );
        return;
      }
      if (editorUiController) {
        editorUiController.focusHtmlEditor();
      } else {
        htmlEditor.focus();
      }
      insertHtmlAtSelection(html);
    });

    frame.open();
  };

  const isValidAttributeName = (name: string) => /^[A-Za-z0-9:_.-]+$/.test(name);

  const escapeAttributeValue = (value: string) =>
    value
      .replace(/&/g, '&amp;')
      .replace(/"/g, '&quot;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');

  const normalizeAttributes = (attrs: { name: string; value: string }[]) => {
    const seen = new Set<string>();
    const normalized: { name: string; value: string }[] = [];
    for (let i = attrs.length - 1; i >= 0; i -= 1) {
      const name = attrs[i].name.trim();
      if (!name || name === 'data-codellia-id' || !isValidAttributeName(name) || seen.has(name)) {
        continue;
      }
      seen.add(name);
      normalized.push({ name, value: attrs[i].value });
    }
    return normalized.reverse();
  };

  const elementsApi = {
    subscribeSelection,
    subscribeContentChange,
    getElementText: (lcId: string) => {
      const info = getEditableElementText(htmlModel.getValue(), lcId);
      return info ? info.text : null;
    },
    updateElementText: (lcId: string, text: string) => {
      const html = htmlModel.getValue();
      const info = getEditableElementText(html, lcId);
      if (!info) {
        return false;
      }
      if (info.text === text) {
        return true;
      }
      applyHtmlEdit(info.startOffset, info.endOffset, text);
      return true;
    },
    getElementAttributes: (lcId: string) => {
      const info = getEditableElementAttributes(htmlModel.getValue(), lcId);
      return info ? info.attributes : null;
    },
    updateElementAttributes: (lcId: string, attributes: { name: string; value: string }[]) => {
      const html = htmlModel.getValue();
      const info = getEditableElementAttributes(html, lcId);
      if (!info) {
        return false;
      }
      const normalized = normalizeAttributes(attributes);
      const attrText = normalized.length
        ? ` ${normalized
            .map((attr) => `${attr.name}="${escapeAttributeValue(attr.value)}"`)
            .join(' ')}`
        : '';
      const closing = info.selfClosing ? ' />' : '>';
      const nextStartTag = `<${info.tagName}${attrText}${closing}`;
      const currentStartTag = html.slice(info.startOffset, info.endOffset);
      if (currentStartTag === nextStartTag) {
        return true;
      }
      applyHtmlEdit(info.startOffset, info.endOffset, nextStartTag);
      return true;
    },
  };

  const updateUndoRedoState = () => {
    const model = editorUiController?.getActiveEditor()?.getModel();
    const canUndo = Boolean(model && model.canUndo());
    const canRedo = Boolean(model && model.canRedo());
    toolbarApi?.update({ canUndo, canRedo });
  };

  const openShadowHintModal = () => modalController?.openShadowHintModal();
  const closeShadowHintModal = () => modalController?.closeShadowHintModal();
  const handleMissingMarkers = () => modalController?.handleMissingMarkers();

  editorUiController = createEditorUiController({
    ui,
    canEditJs,
    htmlEditor,
    cssEditor,
    jsEditor,
    compactEditorBreakpoint: COMPACT_EDITOR_BREAKPOINT,
    getViewportWidth: () => Math.round(window.visualViewport?.width ?? window.innerWidth),
    getJsEnabled: () => jsEnabled,
    getShadowDomEnabled: () => shadowDomEnabled,
    onActiveEditorChange: () => {
      updateUndoRedoState();
    },
    onCompactEditorModeChange: (isCompact) => {
      toolbarApi?.update({ compactEditorMode: isCompact });
      viewportController.applyViewportLayout();
    },
    onOpenMedia: openMediaModal,
    onRunJs: () => preview?.requestRunJs(),
    onOpenShadowHint: openShadowHintModal,
  });
  editorUiController.initialize();

  const focusHtmlEditor = () => {
    editorUiController?.focusHtmlEditor();
  };

  const getPreviewCss = () => (tailwindEnabled ? tailwindCss : cssModel.getValue());

  preview = createPreviewController({
    iframe: ui.iframe,
    postId,
    targetOrigin,
    monaco,
    htmlModel,
    cssModel,
    jsModel,
    htmlEditor,
    cssEditor,
    focusHtmlEditor,
    getPreviewCss,
    getShadowDomEnabled: () => shadowDomEnabled,
    getLiveHighlightEnabled: () => liveHighlightEnabled,
    getJsEnabled: () => jsEnabled,
    getExternalScripts: () => externalScripts,
    getExternalStyles: () => externalStyles,
    isTailwindEnabled: () => tailwindEnabled,
    renderShortcodes: async (items) => {
      if (!cfg.renderShortcodesUrl || !wp?.apiFetch) {
        return {};
      }
      try {
        const res = await wp.apiFetch({
          url: cfg.renderShortcodesUrl,
          method: 'POST',
          data: {
            post_id: postId,
            shortcodes: items.map((item) => ({ id: item.id, shortcode: item.shortcode })),
          },
        });
        if (res?.ok && res.results && typeof res.results === 'object') {
          return res.results as Record<string, string>;
        }
      } catch (error) {
        // eslint-disable-next-line no-console
        console.error('[Codellia] Shortcode render failed', error);
      }
      return {};
    },
    onSelect: (lcId) => {
      selectedLcId = lcId;
      notifySelection();
    },
    onOpenElementsTab: () => {
      if (!settingsOpen) {
        setSettingsOpen(true);
      }
      if (activeSettingsTab !== 'elements') {
        settingsApi?.openTab('elements');
      }
    },
    onMissingMarkers: () => {
      handleMissingMarkers();
    },
  });
  if (pendingIframeLoad) {
    pendingIframeLoad = false;
    preview.handleIframeLoad();
  }
  syncElementsTabState();

  tailwindCompiler = createTailwindCompiler({
    apiFetch: wp.apiFetch,
    restCompileUrl: cfg.restCompileUrl,
    postId,
    getHtml: () => htmlModel.getValue(),
    getCss: () => cssModel.getValue(),
    isTailwindEnabled: () => tailwindEnabled,
    onCssCompiled: (css) => {
      tailwindCss = css;
      preview?.sendCssUpdate(css);
    },
    onStatus: (text) => createSnackbar('error', text, NOTICE_IDS.tailwind, NOTICE_ERROR_DURATION_MS),
    onStatusClear: () => removeNotice(NOTICE_IDS.tailwind),
  });

  sendRenderDebounced = debounce(() => preview?.sendRender(), 120);
  compileTailwindDebounced = debounce(() => tailwindCompiler?.compile(), 300);

  const setJsEnabled = (enabled: boolean) => {
    jsEnabled = enabled;
    editorUiController?.syncJsState();
    if (!preview) {
      return;
    }
    if (!enabled) {
      preview.sendExternalScripts([]);
      preview.requestDisableJs();
      return;
    }
    preview.sendExternalScripts(externalScripts);
    preview.queueInitialJsRun();
  };

  const setShadowDomEnabled = (enabled: boolean) => {
    shadowDomEnabled = enabled;
    editorUiController?.syncShadowDomState();
    if (!shadowDomEnabled) {
      closeShadowHintModal();
    }
    preview?.sendRender();
    preview?.sendExternalScripts(jsEnabled ? externalScripts : []);
    preview?.sendExternalStyles(externalStyles);
    if (!jsEnabled) {
      preview?.requestDisableJs();
      return;
    }
    preview?.requestRunJs();
  };

  const setLiveHighlightEnabled = (enabled: boolean) => {
    liveHighlightEnabled = enabled;
    preview?.sendLiveHighlightUpdate(enabled);
  };

  const setTailwindEnabled = (enabled: boolean) => {
    tailwindEnabled = enabled;
    ui.app.classList.toggle('is-tailwind', enabled);
    toolbarApi?.update({ tailwindEnabled: enabled });
    if (enabled) {
      preview?.sendRender();
      tailwindCompiler?.compile();
    } else {
      const editorSplitState = viewportController.getEditorSplitState();
      if (editorSplitState.active && editorSplitState.lastHtmlHeight > 0) {
        viewportController.setEditorSplitHeight(editorSplitState.lastHtmlHeight);
      }
      preview?.sendRender();
    }
  };

  settingsApi = initSettings({
    container: ui.settingsBody,
    header: ui.settingsHeader,
    data: initialState.settingsData,
    postId,
    onLayoutChange: (nextLayout) => {
      const currentResolved = getResolvedLayout();
      layoutMode = resolveLayout(nextLayout);
      const nextResolved = getResolvedLayout();
      if (nextResolved !== currentResolved && basePreviewUrl) {
        ui.iframe.src = buildPreviewRefreshUrl(getPreviewUrl());
      }
    },
    onShadowDomToggle: setShadowDomEnabled,
    onShortcodeToggle: (enabled) => {
      shortcodeEnabled = enabled;
    },
    onSinglePageToggle: (enabled) => {
      singlePageEnabled = enabled;
    },
    onLiveHighlightToggle: setLiveHighlightEnabled,
    onExternalScriptsChange: (scripts) => {
      externalScripts = scripts;
      preview?.sendExternalScripts(jsEnabled ? externalScripts : []);
    },
    onExternalStylesChange: (styles) => {
      externalStyles = styles;
      preview?.sendExternalStyles(externalStyles);
    },
    onTabChange: (tab) => {
      activeSettingsTab = tab;
      syncElementsTabState();
    },
    onPendingUpdatesChange: (nextState: PendingSettingsState) => {
      pendingSettingsUpdates = { ...nextState.updates };
      hasUnsavedSettings = nextState.hasUnsavedSettings;
      hasSettingsValidationErrors = nextState.hasValidationErrors;
      syncUnsavedUi();
    },
    onClosePanel: () => setSettingsOpen(false),
    elementsApi,
  });

  const handleViewportResize = debounce(() => {
    editorUiController?.updateCompactEditorMode();
    viewportController.applyViewportLayout();
    syncNoticeOffset();
  }, 100);
  window.addEventListener('resize', handleViewportResize);
  window.visualViewport?.addEventListener('resize', handleViewportResize);

  setTailwindEnabled(tailwindEnabled);
  setJsEnabled(jsEnabled);
  preview?.flushPendingJsAction();
  viewportController.applyViewportLayout(true);

  htmlModel.onDidChangeContent(() => {
    preview?.resetCanonicalCache();
    preview?.clearSelectionHighlight();
    sendRenderDebounced?.();
    if (tailwindEnabled) {
      compileTailwindDebounced?.();
    }
    updateUndoRedoState();
    if (suppressSelectionClear === 0) {
      selectedLcId = null;
      notifySelection();
    }
    notifyContentChange();
    syncUnsavedUi();
  });
  cssModel.onDidChangeContent(() => {
    if (!tailwindEnabled) {
      sendRenderDebounced?.();
    }
    if (tailwindEnabled) {
      compileTailwindDebounced?.();
    }
    preview?.clearSelectionHighlight();
    preview?.clearCssSelectionHighlight();
    updateUndoRedoState();
    syncUnsavedUi();
  });

  jsModel.onDidChangeContent(() => {
    updateUndoRedoState();
    syncUnsavedUi();
  });

}

main().catch((e) => {
  // eslint-disable-next-line no-console
  console.error(e);
});


